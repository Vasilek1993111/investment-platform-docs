# Физическая модель базы данных InvestmentDataLoaderService

## 1. Обзор

Данный документ описывает физическую реализацию базы данных на уровне СУБД PostgreSQL:
- Партиционирование таблиц
- Индексы и их стратегии
- Размеры объектов и статистика
- Оптимизации производительности
- Настройки хранения

---

## 2. Партиционирование

### 2.1. Общая информация о партиционировании

База данных использует **декларативное партиционирование PostgreSQL** (RANGE partitioning) для оптимизации работы с большими объемами временных данных.

**Преимущества партиционирования:**
- Ускорение запросов за счет partition pruning (отсечение ненужных партиций)
- Упрощение управления данными (удаление старых партиций)
- Параллельная обработка запросов по партициям
- Улучшение производительности индексов (меньшие индексы на партицию)

### 2.2. Партиционированные таблицы

#### 2.2.1. `invest_candles.minute_candles`
**Тип партиционирования:** RANGE по `time`  
**Гранулярность:** По дням  
**Количество партиций:** ~944 партиции

**Стратегия:**
- Каждая партиция содержит данные за один торговый день
- Имя партиции: `minute_candles_YYYY_MM_DD`
- Диапазон: от предыдущего дня 21:00 UTC до текущего дня 21:00 UTC
- Создается автоматически через функцию `create_minute_candles_partition()`

**Пример партиций:**
- `minute_candles_2025_01_15` - данные за 15 января 2025
- `minute_candles_2025_01_16` - данные за 16 января 2025

**Размер партиций:**
- Типичный размер: 20-30 MB (данные) + 20-30 MB (индексы) = ~50 MB
- Количество строк на партицию: ~150,000 - 190,000 записей
- Зависит от количества инструментов и активности торгов

**Ключ партиционирования:** `time` (TIMESTAMP WITH TIME ZONE)

---

#### 2.2.2. `invest_candles.daily_candles`
**Тип партиционирования:** RANGE по `time`  
**Гранулярность:** По месяцам  
**Количество партиций:** ~43 партиции

**Стратегия:**
- Каждая партиция содержит данные за один месяц
- Имя партиции: `daily_candles_YYYY_MM`
- Диапазон: от последнего дня предыдущего месяца 21:00 UTC до последнего дня текущего месяца 21:00 UTC
- Создается автоматически через функцию `create_daily_candles_partition()`

**Пример партиций:**
- `daily_candles_2025_01` - данные за январь 2025
- `daily_candles_2025_02` - данные за февраль 2025

**Размер партиций:**
- Зависит от количества инструментов и торговых дней в месяце
- Обычно меньше, чем партиции минутных свечей

**Ключ партиционирования:** `time` (TIMESTAMP WITH TIME ZONE)

---

#### 2.2.3. `invest_prices.close_prices`
**Тип партиционирования:** RANGE по `price_date`  
**Гранулярность:** По месяцам  
**Количество партиций:** ~37 партиций

**Стратегия:**
- Каждая партиция содержит цены закрытия за один месяц
- Имя партиции: `close_prices_YYYY_MM`
- Диапазон: от первого дня месяца до первого дня следующего месяца
- Создается автоматически через функцию `create_close_prices_partition()`

**Пример партиций:**
- `close_prices_2025_01` - цены закрытия за январь 2025
- `close_prices_2025_02` - цены закрытия за февраль 2025

**Ключ партиционирования:** `price_date` (DATE)

---

#### 2.2.4. `invest_prices.open_prices`
**Тип партиционирования:** RANGE по `price_date`  
**Гранулярность:** По месяцам  
**Количество партиций:** ~36 партиций

**Стратегия:** Аналогична `close_prices`

**Ключ партиционирования:** `price_date` (DATE)

---

#### 2.2.5. `invest_prices.close_prices_evening_session`
**Тип партиционирования:** RANGE по `price_date`  
**Гранулярность:** По месяцам  
**Количество партиций:** ~36 партиций

**Стратегия:** Аналогична `close_prices`, но для вечерней сессии

---

#### 2.2.6. `invest.last_prices`
**Тип партиционирования:** RANGE по `time`  
**Гранулярность:** По дням  
**Количество партиций:** ~851 партиция

**Стратегия:**
- Каждая партиция содержит последние цены за один день
- Имя партиции: `last_prices_YYYY_MM_DD`
- Создается автоматически через функцию `create_last_prices_daily_partition()`

**Ключ партиционирования:** `time` (TIMESTAMP WITHOUT TIME ZONE)

---

#### 2.2.7. `invest_prices.trades`
**Тип партиционирования:** RANGE по `time`  
**Гранулярность:** По дням  
**Количество партиций:** ~1096 партиций

**Стратегия:**
- Каждая партиция содержит сделки за один день
- Имя партиции: `trades_YYYY_MM_DD` (предположительно)

**Ключ партиционирования:** `time` (TIMESTAMP WITHOUT TIME ZONE)

---

### 2.3. Статистика партиционирования

| Таблица | Тип партиционирования | Гранулярность | Количество партиций | Средний размер партиции |
|---------|------------------------|---------------|---------------------|-------------------------|
| `minute_candles` | RANGE | День | ~944 | ~50 MB |
| `daily_candles` | RANGE | Месяц | ~43 | Зависит от месяца |
| `close_prices` | RANGE | Месяц | ~37 | Зависит от месяца |
| `open_prices` | RANGE | Месяц | ~36 | Зависит от месяца |
| `close_prices_evening_session` | RANGE | Месяц | ~36 | Зависит от месяца |
| `last_prices` | RANGE | День | ~851 | Зависит от активности |
| `trades` | RANGE | День | ~1096 | Зависит от активности |

**Общее количество партиций:** ~3000+ партиций

---

### 2.4. Управление партициями

#### 2.4.1. Создание партиций

Партиции создаются автоматически через функции:
- `invest_utils.create_minute_candles_partition(p_date)`
- `invest_utils.create_daily_candles_partition(p_date)`
- `invest_utils.create_close_prices_partition(p_date)`
- `invest_utils.create_open_prices_partition(p_date)`
- `invest.create_last_prices_daily_partition(p_date)`

**Рекомендации:**
- Создавать партиции заранее (например, на месяц вперед)
- Использовать планировщик задач для автоматизации
- Проверять существование партиции перед созданием

#### 2.4.2. Удаление старых партиций

Функция `invest_utils.cleanup_old_daily_partitions(retention_days)` позволяет удалять старые партиции:
- По умолчанию удаляет партиции старше 730 дней (2 года)
- Можно настроить период хранения
- Логирует операции через RAISE NOTICE

**Пример:**
```sql
-- Удалить партиции старше года
SELECT invest_utils.cleanup_old_daily_partitions(365);
```

---

## 3. Индексы

### 3.1. Стратегия индексирования

База данных использует **B-tree индексы** (по умолчанию в PostgreSQL) для оптимизации запросов.

**Принципы индексирования:**
1. **Первичные ключи:** Всегда индексируются автоматически
2. **Внешние ключи (логические):** Индексируются для ускорения JOIN
3. **Часто используемые фильтры:** Индексируются для ускорения WHERE
4. **Партиционированные таблицы:** Индексы создаются на каждой партиции отдельно

### 3.2. Индексы по таблицам

#### 3.2.1. Справочные таблицы

**`invest_ref.shares`**
- `shares_pkey` (PRIMARY KEY) на `figi` - уникальный индекс

**`invest_ref.futures`**
- `futures_pkey` (PRIMARY KEY) на `figi` - уникальный индекс

**`invest_ref.indicatives`**
- `indicatives_pkey` (PRIMARY KEY) на `figi` - уникальный индекс

**`invest_ref.dividends`**
- `dividends_pkey` (PRIMARY KEY) на `id` - уникальный индекс
- Рекомендуется индекс на `figi` для связи с инструментами

**`invest_ref.fundamentals`**
- `fundamentals_pkey` (PRIMARY KEY) на `id` - уникальный индекс
- `idx_fundamentals_figi` на `figi` - индекс для связи с инструментами

---

#### 3.2.2. Ценовые таблицы

**`invest_prices.close_prices` (партиционированная)**
- PRIMARY KEY на `(figi, price_date)` - составной уникальный индекс
- `idx_close_prices_date` на `price_date` - индекс для фильтрации по дате
- `idx_close_prices_figi_date` на `(figi, price_date)` - составной индекс

**Примечание:** Индексы создаются на родительской таблице с `ONLY`, что означает, что они не наследуются партициями. Каждая партиция имеет свои собственные индексы.

**`invest_prices.open_prices` (партиционированная)**
- PRIMARY KEY на `(figi, price_date)` - составной уникальный индекс
- Аналогичная стратегия индексирования, как у `close_prices`

**`invest.last_prices` (партиционированная)**
- PRIMARY KEY на `(figi, time)` - составной уникальный индекс
- Индексы создаются на каждой партиции отдельно

**`invest_prices.trades` (партиционированная)**
- PRIMARY KEY на `(figi, time)` - составной уникальный индекс
- Индексы создаются на каждой партиции отдельно

---

#### 3.2.3. Свечные таблицы

**`invest_candles.daily_candles` (партиционированная)**
- PRIMARY KEY на `(figi, time)` - составной уникальный индекс
- `idx_daily_candles_time` на `time` (ONLY) - индекс на родительской таблице
- `idx_daily_candles_figi_time` на `(figi, time)` (ONLY) - составной индекс на родительской таблице

**Индексы на партициях:**
Каждая партиция имеет свои индексы:
- `daily_candles_YYYY_MM_time_idx` на `time`
- `daily_candles_YYYY_MM_figi_time_idx` на `(figi, time)`

**`invest_candles.minute_candles` (партиционированная)**
- PRIMARY KEY на `(figi, time)` - составной уникальный индекс
- `idx_minute_candles_time` на `time` (ONLY) - индекс на родительской таблице
- `idx_minute_candles_figi_time` на `(figi, time)` (ONLY) - составной индекс на родительской таблице

**Индексы на партициях:**
Каждая партиция имеет свои индексы:
- `minute_candles_YYYY_MM_DD_time_idx` на `time`
- `minute_candles_YYYY_MM_DD_figi_time_idx` на `(figi, time)`

**Размер индексов:**
- Для минутных свечей: индексы занимают ~50% от размера данных (20-30 MB индексов на 20-30 MB данных)
- Это нормально для таблиц с частыми запросами по времени и FIGI

---

#### 3.2.4. Аналитические таблицы

**`invest_candles.candle_pattern_analysis`**
- `pk_candle_pattern_analysis` (PRIMARY KEY) на `id` - уникальный индекс
- Рекомендуется индекс на `figi` для связи с инструментами
- Рекомендуется индекс на `analysis_date` для фильтрации по дате

**`invest_candles.backtest_results`**
- `backtest_results_pkey` (PRIMARY KEY) на `id` - уникальный индекс
- Рекомендуется индекс на `figi` для связи с инструментами
- Рекомендуется индекс на `pattern_analysis_id` для связи с анализом паттернов
- Рекомендуется индекс на `analysis_date` для фильтрации по дате

---

#### 3.2.5. Служебные таблицы

**`invest_utils.system_logs`**
- PRIMARY KEY на `id` - уникальный индекс
- Рекомендуется индекс на `task_id` для поиска по задаче
- Рекомендуется индекс на `created_at` для фильтрации по времени

---

### 3.3. Типы индексов

**B-tree индексы (по умолчанию):**
- Используются для всех индексов
- Оптимальны для:
  - Равенства (=)
  - Диапазонов (<, >, BETWEEN)
  - Сортировки (ORDER BY)
  - LIKE с префиксом

**Особенности:**
- Все индексы используют B-tree структуру
- Поддерживают многоколоночные индексы (составные)
- Автоматически поддерживаются при вставке/обновлении/удалении

---

### 3.4. Оптимизация индексов

#### 3.4.1. Partition Pruning

PostgreSQL автоматически использует partition pruning для партиционированных таблиц:
- При запросе с фильтром по ключу партиционирования, PostgreSQL исключает ненужные партиции
- Это значительно ускоряет запросы

**Пример:**
```sql
-- Запрос использует только партицию за январь 2025
SELECT * FROM invest.daily_candles 
WHERE time >= '2025-01-01' AND time < '2025-02-01';
```

#### 3.4.2. Индексы на партициях

Каждая партиция имеет свои индексы, что обеспечивает:
- Меньший размер индексов (быстрее поиск)
- Параллельную обработку индексов разных партиций
- Независимое обслуживание индексов

#### 3.4.3. Рекомендации по индексированию

1. **Не создавать избыточные индексы:**
   - Каждый индекс замедляет INSERT/UPDATE/DELETE
   - Индексы занимают место на диске

2. **Использовать составные индексы:**
   - Для запросов с несколькими условиями
   - Порядок колонок важен (чаще используемые - первыми)

3. **Мониторинг использования индексов:**
   - Использовать `pg_stat_user_indexes` для анализа
   - Удалять неиспользуемые индексы

---

## 4. Размеры объектов базы данных

### 4.1. Крупнейшие таблицы

| Таблица | Схема | Общий размер | Размер данных | Размер индексов | Примерное количество строк |
|---------|-------|--------------|---------------|-----------------|----------------------------|
| `mt5_ticks_p20251009` | invest | 589 MB | 588 MB | 176 kB | ~миллионы |
| `mt5_ticks_p20250902` | invest | 551 MB | 551 MB | 168 kB | ~миллионы |
| `mt5_ticks_p20251010` | invest | 339 MB | 339 MB | 112 kB | ~миллионы |
| `minute_candles_2026_01_21` | invest_candles | 58 MB | 27 MB | 30 MB | ~188,523 |
| `minute_candles_2025_11_10` | invest_candles | 51 MB | 24 MB | 27 MB | ~168,544 |
| `system_logs` | invest_utils | 50 MB | 50 MB | 40 kB | ~148,972 |

**Примечание:** MT5 таблицы (тики) являются самыми большими по размеру, но не являются основными таблицами системы.

---

### 4.2. Размеры по типам данных

**Минутные свечи (minute_candles):**
- Средний размер партиции: ~50 MB (данные + индексы)
- Данные: ~25 MB
- Индексы: ~25 MB
- Строк на партицию: ~150,000 - 190,000

**Дневные свечи (daily_candles):**
- Размер зависит от количества инструментов и дней в месяце
- Обычно меньше, чем минутные свечи

**Цены закрытия/открытия:**
- Размер зависит от количества инструментов и дней в месяце
- Обычно меньше, чем свечи

**Системные логи:**
- Текущий размер: ~50 MB
- Растет со временем
- Рекомендуется периодическая очистка старых логов

---

### 4.3. Материализованные представления

| Представление | Схема | Размер | Индексы |
|---------------|-------|--------|---------|
| `history_volume_aggregation` | invest_views | 168 kB | Нет |
| `historical_price_extremes` | invest_views | 144 kB | Есть |

**Примечание:** Материализованные представления занимают относительно мало места, так как содержат агрегированные данные.

---

## 5. Статистика и оптимизация

### 5.1. Статистика PostgreSQL

PostgreSQL собирает статистику о распределении данных для оптимизатора запросов:

**Ключевые метрики:**
- `n_distinct` - количество уникальных значений
- `correlation` - корреляция между физическим порядком строк и значениями
- `most_common_vals` - наиболее частые значения
- `most_common_freqs` - частоты наиболее частых значений

**Примеры статистики:**

**`invest_ref.futures`:**
- `lot`: n_distinct = 1 (все значения одинаковые)
- `currency`: n_distinct = 1 (все значения 'rub')
- `exchange`: n_distinct = 2 (большинство 'forts_futures_weekend')
- `min_price_increment`: n_distinct = 12 (разнообразие значений)

**`invest_ref.shares`:**
- `exchange`: n_distinct = 1 (все 'moex_mrng_evng_e_wknd_dlr')
- `currency`: n_distinct = 1 (все 'rub')
- `sector`: n_distinct = 12 (разнообразие секторов)
- `lot`: n_distinct = 7 (различные значения лотности)

---

### 5.2. Автоматический сбор статистики

PostgreSQL автоматически собирает статистику через:
- `AUTOANALYZE` - автоматический анализ таблиц
- Запускается при достижении порога изменений (10% строк + 50 строк)

**Мониторинг:**
```sql
SELECT 
    schemaname,
    tablename,
    last_autoanalyze,
    autoanalyze_count
FROM pg_stat_user_tables
WHERE schemaname IN ('invest', 'invest_ref', 'invest_prices', 'invest_candles');
```

---

### 5.3. Вакуум и обслуживание

**Автоматический вакуум (AUTOVACUUM):**
- Автоматически очищает "мертвые" строки
- Обновляет статистику для оптимизатора
- Запускается при достижении порога

**Рекомендации:**
- Мониторить `n_dead_tup` в `pg_stat_user_tables`
- При большом количестве мертвых строк запускать `VACUUM` вручную
- Для партиционированных таблиц вакуум выполняется на каждой партиции отдельно

**Пример:**
```sql
-- Вакуум конкретной партиции
VACUUM ANALYZE invest_candles.minute_candles_2025_01_15;

-- Вакуум всей партиционированной таблицы (вакуумит все партиции)
VACUUM ANALYZE invest_candles.minute_candles;
```

---

## 6. Производительность

### 6.1. Оптимизации запросов

#### 6.1.1. Partition Pruning

**Как работает:**
- При запросе с фильтром по ключу партиционирования PostgreSQL исключает ненужные партиции
- Это значительно ускоряет запросы, особенно для больших таблиц

**Пример:**
```sql
-- Запрос обрабатывает только партиции за январь 2025
SELECT * FROM invest.daily_candles 
WHERE time >= '2025-01-01' AND time < '2025-02-01'
  AND figi = 'BBG004S68DD6';
```

**Эффективность:**
- Вместо сканирования всех ~43 партиций обрабатывается только 1 партиция
- Ускорение в десятки раз

---

#### 6.1.2. Параллельное выполнение запросов

PostgreSQL может параллельно обрабатывать партиции:
- При запросах без фильтра по партициям
- Использует несколько worker процессов
- Ускоряет агрегацию и сканирование

**Настройка:**
```sql
-- Включить параллельное выполнение
SET max_parallel_workers_per_gather = 4;
```

---

#### 6.1.3. Индексное сканирование

Индексы на партициях обеспечивают:
- Быстрый поиск по FIGI и времени
- Эффективные JOIN операции
- Оптимальную сортировку

**Пример:**
```sql
-- Использует индекс на (figi, time)
SELECT * FROM invest.minute_candles 
WHERE figi = 'BBG004S68DD6' 
  AND time >= '2025-01-15 10:00:00'
ORDER BY time;
```

---

### 6.2. Оптимизация вставки данных

#### 6.2.1. Массовая вставка

**Рекомендации:**
1. Использовать `COPY` для массовой вставки вместо множественных `INSERT`
2. Отключать индексы временно при массовой загрузке (требует осторожности)
3. Использовать транзакции для группировки вставок

**Пример:**
```sql
BEGIN;
-- Массовая вставка
COPY invest_candles.minute_candles FROM '/path/to/data.csv' WITH CSV;
COMMIT;
```

#### 6.2.2. Партиционирование и вставка

**Преимущества:**
- Вставка в одну партицию не блокирует другие партиции
- Можно параллельно вставлять данные в разные партиции
- Меньшие индексы быстрее обновляются

---

### 6.3. Оптимизация запросов

#### 6.3.1. Использование фильтров по партициям

**Хорошо:**
```sql
-- Использует partition pruning
SELECT * FROM invest.daily_candles 
WHERE time >= '2025-01-01' AND time < '2025-02-01';
```

**Плохо:**
```sql
-- Не использует partition pruning эффективно
SELECT * FROM invest.daily_candles 
WHERE EXTRACT(MONTH FROM time) = 1;
```

#### 6.3.2. Использование индексов

**Хорошо:**
```sql
-- Использует индекс на (figi, time)
SELECT * FROM invest.minute_candles 
WHERE figi = 'BBG004S68DD6' 
  AND time >= '2025-01-15 10:00:00';
```

**Плохо:**
```sql
-- Не использует индекс эффективно
SELECT * FROM invest.minute_candles 
WHERE time >= '2025-01-15 10:00:00'
  AND figi = 'BBG004S68DD6';
-- (Порядок условий не критичен, но лучше начинать с индексированного поля)
```

---

## 7. Настройки хранения

### 7.1. Параметры таблиц

**По умолчанию:**
- `fillfactor` = 100 (таблицы заполняются полностью)
- `autovacuum` = включен
- `toast` = автоматически для больших значений

**Рекомендации:**
- Для таблиц с частыми обновлениями можно уменьшить `fillfactor` до 80-90
- Для таблиц только на вставку `fillfactor = 100` оптимален

---

### 7.2. TOAST (The Oversized-Attribute Storage Technique)

PostgreSQL автоматически использует TOAST для больших значений:
- Значения > 2 KB хранятся в отдельной TOAST таблице
- Сжатие для экономии места
- Прозрачно для приложения

**Применение:**
- Большие текстовые поля
- Массивы
- JSONB данные

---

## 8. Мониторинг и обслуживание

### 8.1. Мониторинг размеров

**Запрос для мониторинга размеров таблиц:**
```sql
SELECT 
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) AS table_size,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) - 
                   pg_relation_size(schemaname||'.'||tablename)) AS indexes_size
FROM pg_tables
WHERE schemaname IN ('invest', 'invest_ref', 'invest_prices', 'invest_candles', 'invest_utils')
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

---

### 8.2. Мониторинг партиций

**Запрос для статистики партиций:**
```sql
SELECT 
    n.nspname AS schema_name,
    t.relname AS table_name,
    COUNT(c.relname) AS partition_count,
    pg_size_pretty(SUM(pg_total_relation_size(n.nspname||'.'||c.relname))) AS total_size
FROM pg_class t
JOIN pg_namespace n ON n.oid = t.relnamespace
LEFT JOIN pg_inherits i ON i.inhparent = t.oid
LEFT JOIN pg_class c ON c.oid = i.inhrelid
WHERE n.nspname IN ('invest', 'invest_ref', 'invest_prices', 'invest_candles')
    AND t.relkind = 'p'
GROUP BY n.nspname, t.relname
ORDER BY partition_count DESC;
```

---

### 8.3. Мониторинг индексов

**Запрос для анализа использования индексов:**
```sql
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_scan AS index_scans,
    idx_tup_read AS tuples_read,
    idx_tup_fetch AS tuples_fetched,
    pg_size_pretty(pg_relation_size(schemaname||'.'||indexname)) AS index_size
FROM pg_stat_user_indexes
WHERE schemaname IN ('invest', 'invest_ref', 'invest_prices', 'invest_candles')
ORDER BY idx_scan DESC;
```

**Интерпретация:**
- `idx_scan = 0` - индекс не используется, можно рассмотреть удаление
- Высокий `idx_tup_read` при низком `idx_tup_fetch` - индекс используется неэффективно

---

### 8.4. Плановое обслуживание

#### 8.4.1. Ежедневные задачи

1. **Создание партиций:**
   - Создавать партиции на неделю/месяц вперед
   - Автоматизировать через cron или планировщик

2. **Обновление статистики:**
   - Автоматический ANALYZE обычно достаточен
   - При необходимости запускать вручную после массовых операций

#### 8.4.2. Еженедельные задачи

1. **Вакуум:**
   - Автоматический VACUUM обычно достаточен
   - Мониторить `n_dead_tup` для выявления проблем

2. **Обновление материализованных представлений:**
   - Обновлять `daily_volume_aggregation`
   - Обновлять `history_volume_aggregation`
   - Обновлять `historical_price_extremes`

#### 8.4.3. Ежемесячные задачи

1. **Очистка старых партиций:**
   - Удалять партиции старше retention периода
   - Использовать `cleanup_old_daily_partitions()`

2. **Анализ производительности:**
   - Проверять неиспользуемые индексы
   - Анализировать медленные запросы
   - Оптимизировать при необходимости

---

## 9. Рекомендации по оптимизации

### 9.1. Производительность запросов

1. **Всегда фильтровать по ключу партиционирования:**
   - Использовать прямые сравнения дат/времени
   - Избегать функций над ключом партиционирования

2. **Использовать индексы эффективно:**
   - Начинать запросы с индексированных полей
   - Использовать составные индексы для многоколоночных фильтров

3. **Ограничивать результаты:**
   - Использовать `LIMIT` когда возможно
   - Избегать `SELECT *` для больших таблиц

---

### 9.2. Управление данными

1. **Регулярная очистка:**
   - Удалять старые партиции по расписанию
   - Очищать старые логи
   - Архивировать исторические данные при необходимости

2. **Мониторинг роста:**
   - Отслеживать рост таблиц и партиций
   - Планировать расширение хранилища заранее

---

### 9.3. Резервное копирование

1. **Стратегия бэкапов:**
   - Использовать `pg_dump` для логических бэкапов
   - Использовать `pg_basebackup` для физических бэкапов
   - Учитывать партиционирование при планировании

2. **Восстановление:**
   - Тестировать процедуры восстановления
   - Документировать процесс восстановления

---

## 10. Ограничения и особенности

### 10.1. Ограничения партиционирования

1. **Нет глобальных индексов:**
   - Индексы создаются на каждой партиции отдельно
   - Это нормально и обеспечивает лучшую производительность

2. **Ограничения уникальности:**
   - Уникальные ограничения должны включать ключ партиционирования
   - PRIMARY KEY всегда включает ключ партиционирования

3. **Внешние ключи:**
   - Внешние ключи не определены на уровне БД
   - Связи реализованы на уровне приложения

---

### 10.2. Особенности производительности

1. **Большое количество партиций:**
   - ~3000+ партиций может замедлить планирование запросов
   - Рекомендуется ограничивать количество активных партиций

2. **Размер индексов:**
   - Индексы могут занимать значительное место (до 50% от данных)
   - Это нормально для таблиц с частыми запросами

---

## 11. Метрики и KPI

### 11.1. Ключевые метрики

**Размер базы данных:**
- Общий размер: зависит от периода хранения данных
- Рост: ~50-100 MB в день (для минутных свечей)
- Партиции: ~3000+ партиций

**Производительность:**
- Partition pruning: ускоряет запросы в 10-100 раз
- Индексное сканирование: обеспечивает быстрый поиск
- Параллельное выполнение: ускоряет агрегацию

**Обслуживание:**
- Автоматический вакуум: работает в фоне
- Автоматический анализ: обновляет статистику
- Создание партиций: автоматизировано через функции

---

## 12. Следующие шаги

Для дальнейшей оптимизации рекомендуется:

1. **Анализ запросов:**
   - Использовать `EXPLAIN ANALYZE` для анализа планов выполнения
   - Выявлять медленные запросы
   - Оптимизировать при необходимости

2. **Настройка PostgreSQL:**
   - Оптимизировать параметры `postgresql.conf`
   - Настроить `shared_buffers`, `work_mem`, `maintenance_work_mem`
   - Настроить `autovacuum` параметры

3. **Мониторинг:**
   - Настроить мониторинг размеров таблиц
   - Настроить алерты на рост базы данных
   - Отслеживать производительность запросов

4. **Документация:**
   - Документировать процедуры обслуживания
   - Документировать процедуры восстановления
   - Документировать процедуры масштабирования
